package org.grits.toolbox.entry.ms.property;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBException;

import org.apache.log4j.Logger;
import org.eclipse.jface.resource.ImageDescriptor;
import org.grits.toolbox.core.dataShare.PropertyHandler;
import org.grits.toolbox.core.datamodel.Entry;
import org.grits.toolbox.core.datamodel.io.PropertyWriter;
import org.grits.toolbox.core.datamodel.property.NotImplementedException;
import org.grits.toolbox.core.datamodel.property.ProjectProperty;
import org.grits.toolbox.core.datamodel.property.Property;
import org.grits.toolbox.core.datamodel.property.PropertyDataFile;
import org.grits.toolbox.core.datamodel.util.DataModelSearch;
import org.grits.toolbox.core.utilShare.DeleteUtils;
import org.grits.toolbox.core.utilShare.XMLUtils;
import org.grits.toolbox.entry.ms.Activator;
import org.grits.toolbox.entry.ms.ImageRegistry;
import org.grits.toolbox.entry.ms.property.datamodel.ExternalQuantAlias;
import org.grits.toolbox.entry.ms.property.datamodel.ExternalQuantFileToAlias;
import org.grits.toolbox.entry.ms.property.datamodel.MSPropertyDataFile;
import org.grits.toolbox.entry.ms.property.datamodel.MassSpecMetaData;
import org.grits.toolbox.entry.ms.property.io.MassSpecPropertyWriter;
import org.grits.toolbox.ms.file.MSFileInfo;

/**
 * A Property object specific for MS Entry
 * 
 * @author D Brent Weatherly (dbrentw@uga.edu)
 *
 */
public class MassSpecProperty extends Property {
	// 01/12/18:  CInternal Standard Quant was added to the MetaData. No changes to the property, but this affects the reader but was able to keep at ver 1.3
	public static final String CURRENT_VERSION = "1.3";
	private static final Logger logger = Logger.getLogger(MassSpecProperty.class);
	public static final String TYPE = "org.grits.toolbox.property.ms";
	protected static MassSpecPropertyWriter writer = new MassSpecPropertyWriter();
	private static final String folderName = "ms";

	protected static ImageDescriptor imageDescriptor = ImageRegistry.getImageDescriptor(Activator.PLUGIN_ID, ImageRegistry.MSImage.MASSSPEC_ICON);
	public static String CONVERT_RAW = "<to be generated by GRITS>";

	private MassSpecMetaData msSettings = null;
	public static List<Class<?>> msMetaDataClasses = new ArrayList<>();
	
	public MassSpecProperty() {
		super();
		if( ! MassSpecProperty.msMetaDataClasses.contains(MassSpecMetaData.class) ) {
			MassSpecProperty.msMetaDataClasses.add(MassSpecMetaData.class);
		}
	}
		
	public PropertyDataFile getMSSettingsFile() {
		Iterator<PropertyDataFile> itr = getDataFiles().iterator();
		while( itr.hasNext() ) {
			PropertyDataFile file = itr.next();
			if( file.getType().equals( MSFileInfo.MSMETADATA_TYPE ) ) {
				return file;
			}
		}
		return null;
	}

	public void adjustPropertyFilePaths() {
		Iterator<PropertyDataFile> itr = getDataFiles().iterator();
		while( itr.hasNext() ) {
			PropertyDataFile file = itr.next();
			if( file.getName().contains("\\") && ! File.separator.equals("\\") ) {
				file.setName( file.getName().replace("\\", File.separator));
			} else if( file.getName().contains("/") && ! File.separator.equals("/") ){
				file.setName( file.getName().replace("/", File.separator));
			}
		}
	}

	public MassSpecMetaData unmarshallSettingsFile( String sFileName ) {
		MassSpecMetaData metaData = null;
		try {
//			metaData = (MassSpecMetaData) XMLUtils.unmarshalObjectXML(sFileName, MassSpecProperty.msMetaDataClasses);
			metaData = (MassSpecMetaData) XMLUtils.unmarshalObjectXML(sFileName, MassSpecMetaData.class);

		} catch (Exception e ) {
			logger.error(e.getMessage(), e);
		}
		return metaData;
	}

	public void marshallSettingsFile( String sFileName, MassSpecMetaData metaData  ) {
		try {
//			String xmlString = XMLUtils.marshalObjectXML(metaData, MassSpecProperty.msMetaDataClasses);
			String xmlString = XMLUtils.marshalObjectXML(metaData);
			//write the serialized data to the folder
			FileWriter fileWriter = new FileWriter(sFileName);
			fileWriter.write(xmlString);
			fileWriter.close();
		} catch (IOException e) {
			logger.error(e.getMessage(), e);
		}
	}

	@Override
	public String getType() {
		return MassSpecProperty.TYPE;
	}

	@Override
	public PropertyWriter getWriter() {
		return MassSpecProperty.writer;
	}
	@Override
	public ImageDescriptor getImage() {
		return MassSpecProperty.imageDescriptor;
	}

	public static String getFoldername() {
		return folderName;
	}

	public MassSpecMetaData getMassSpecMetaData() {
		return msSettings;
	}

	public void setMassSpecMetaData(MassSpecMetaData msSettings) {
		this.msSettings = msSettings;
	}

	public static String getFullyQualifiedFolderName(Entry entry) {
		String workspaceLocation = PropertyHandler.getVariable("workspace_location");
		String projectName = DataModelSearch.findParentByType(entry, ProjectProperty.TYPE).getDisplayName();
		String folderName = workspaceLocation + projectName + File.separator + MassSpecProperty.getFoldername();
		return folderName;		
	}

	public String getFullyQualifiedMetaDataFileName(Entry entry) {
		String msSettings = getMSSettingsFile().getName();
		if( msSettings == null ) {
			return null;
		}
		String workspaceLocation = PropertyHandler.getVariable("workspace_location");
		String projectName = DataModelSearch.findParentByType(entry, ProjectProperty.TYPE).getDisplayName();
		String mzXML = workspaceLocation + projectName + File.separator + MassSpecProperty.getFoldername() +File.separator + msSettings;
		return mzXML;		
	}

	@Override
	public void delete(Entry entry) throws IOException {
		String workspaceLocation = PropertyHandler.getVariable("workspace_location");
		String projectName = DataModelSearch.findParentByType(entry, ProjectProperty.TYPE).getDisplayName();
		String msPath = workspaceLocation+projectName + File.separator + MassSpecProperty.getFoldername();
		
		String sEntryPath = null; // the folder created for each entry under the ms folder
		
		// delete the uploaded files (mzXML, raw, peaklist etc.) from MassSpecMetaData
		if( getMassSpecMetaData() != null ) {
			sEntryPath = deleteSettings(entry, msPath);
		}
		// delete the settings file
		Iterator<PropertyDataFile> itr = getDataFiles().iterator();
		while( itr.hasNext() ) {
			PropertyDataFile file = itr.next();
			if( file.getName().trim().equals("") ) {
				continue;
			}
			DeleteUtils.delete(new File( msPath + File.separator + file.getName() ) );
		}
		
		if( sEntryPath != null ) {
			DeleteUtils.delete(new File(msPath + File.separator + sEntryPath) );
		}
	}
	
	/**
	 * 
	 * @param entry
	 * @param msPath
	 * @return the folder where this settings file is in
	 * @throws IOException
	 */
	public String deleteSettings(Entry entry, String msPath) throws IOException {
//		String workspaceLocation = PropertyHandler.getVariable("workspace_location");
//		String projectName = DataModelSearch.findParentByType(entry, ProjectProperty.TYPE).getDisplayName();
//		String msPath = workspaceLocation+projectName + File.separator + MassSpecProperty.getFoldername();
		
		String sEntryPath = null; // the folder created for each entry under the ms folder
		
		// delete the uploaded files (mzXML, raw, peaklist etc.) from MassSpecMetaData
		if (getMassSpecMetaData().getFileList() == null) // no files have been added yet
			return sEntryPath;
		for (MSPropertyDataFile file: getMassSpecMetaData().getFileList()) {
			if (file.getName() != null && !file.getName().trim().isEmpty()) {
				if( sEntryPath == null && file.getName().contains(File.separator) ) {
					sEntryPath = file.getName().substring(0, file.getName().indexOf(File.separator) );
				}
				DeleteUtils.delete(new File( msPath + File.separator + file.getName() ) );
				try {
					deleteFileFromLockFile(entry, file.getName());
				} catch (JAXBException e) {
					throw new IOException ("Could not remove from the lock file", e);
				}
			}
			if (((MSPropertyDataFile) file).getChildren() != null) {
				for (MSPropertyDataFile child: ((MSPropertyDataFile) file).getChildren()) {
					if( child.getName().trim().equals("") ) {
						continue;
					}
					if( sEntryPath == null && child.getName().contains(File.separator) ) {
						sEntryPath = child.getName().substring(0, child.getName().indexOf(File.separator) );
					}
					DeleteUtils.delete(new File( msPath + File.separator + child.getName() ) );
					try {
						deleteFileFromLockFile(entry, child.getName());
					} catch (JAXBException e) {
						throw new IOException ("Could not remove from the lock file", e);
					}
				}
			}
		}
		return sEntryPath;
	}
	
	/**
	 * Retrieve the full path for the lockfile. 
	 * If the subfolder for mssettings file is not found (some older workspaces), the lock file is created directly under ms folder, 
	 * otherwise it will be created for each separate ms entry
	 * 
	 * @param entry Entry to search under
	 * @return the full path for the lockfile
	 */
	public String getLockFilePath(Entry entry) {
		PropertyDataFile msSettings = getMSSettingsFile();
		if (msSettings == null || msSettings.getName().indexOf(File.separator) == -1) {
			return getFullyQualifiedFolderName(entry) + File.separator + FileLockManager.LOCKFILE_NAME;
		}
		String path = msSettings.getName().substring(0, msSettings.getName().lastIndexOf(File.separator));
		return getFullyQualifiedFolderName(entry) + File.separator + path + File.separator + FileLockManager.LOCKFILE_NAME;
	}
	
	/**
	 * delete the given file from the lock file, does not check whether it is locked!
	 * 
	 * @param entry MS Entry to which the lock file belongs
	 * @param filename file to be removed
	 * @throws IOException
	 * @throws JAXBException
	 */
	public void deleteFileFromLockFile (Entry entry, String filename) throws IOException, JAXBException {
		String path = getLockFilePath(entry);
		FileLockManager mng = FileLockingUtils.readLockFile(path);
		mng.deleteFile(filename);
		FileLockingUtils.writeLockFile(mng, path);
	}
	
	/**
	 * remove the lock for the given file 
	 * 
	 * @param msEntry MS Entry to which the lock file belongs
	 * @param usedBy Entry that locked the file earlier and now tries to remove itself from the file's usedBy list
	 * @param filename the name of the file to be unlocked
	 * 
	 * @throws IOException
	 * @throws JAXBException
	 */
	public void removeLockForFile (Entry msEntry, Entry usedBy, String filename) throws IOException, JAXBException {
		String path = getLockFilePath(msEntry);
		FileLockManager mng = FileLockingUtils.readLockFile(path);
		LockEntry lockEntry = new LockEntry();
		lockEntry.setEntryId(usedBy.getId());
		lockEntry.setEntryName(usedBy.getDisplayName());
		mng.removeLock (filename, lockEntry);
		FileLockingUtils.writeLockFile(mng, path);
	}

	public static Entry getMSParentEntry( Entry entry ) {
		if ( entry.getProperty() instanceof MassSpecProperty ) {
			return entry;
		}
		if ( entry.getParent() != null )
			return MassSpecProperty.getMSParentEntry(entry.getParent());
		return null;
	}

	public boolean updateMSSettings( MassSpecMetaData metaData, String sSettingsFIle ) {
		try {
			marshallSettingsFile(sSettingsFIle, metaData);
		} catch( Exception e ) {
			logger.error(e.getMessage());
			return false;
		}
		return true;
	}
	
	public static boolean copyMSFilesIntoWorkspace(List<MSPropertyDataFile> allFiles, String sMsPath, Entry newMSEntry) {
		try {
			SimpleDateFormat formater = new SimpleDateFormat("yyyy.MM.dd-HH.mm.ss.SSSS");
			Date date = new Date();
			String entryPath = formater.format(date);

			File destMSPath = new File(sMsPath + File.separator + entryPath);
			destMSPath.mkdirs();
			CopyFilesRunnableWithProgress runner = new CopyFilesRunnableWithProgress(allFiles, newMSEntry, sMsPath, entryPath);
			runner.run(null);

			if( ! runner.isSuccessful() ) {
				throw new Exception("Error occurred while copying files into workspace.");
			}
			if( ! runner.iCanceled() ) {
				String msDetails = "msMetaData.xml";
				MassSpecProperty property = (MassSpecProperty) newMSEntry.getProperty();
				MassSpecMetaData metaData = property.getMassSpecMetaData();
				//				MassSpecProperty.marshallSettingsFile(destMSPath + File.separator + msDetails, metaData);
				String sSettingsFile = destMSPath + File.separator + msDetails;
				property.updateMSSettings(metaData, sSettingsFile);

				PropertyDataFile msMetaData = MassSpecMetaData.getNewSettingsFile(entryPath + File.separator + msDetails, metaData);
				property.getDataFiles().add(msMetaData);

				return true;
			}
		} catch( Exception ex ) {
			logger.error(ex.getMessage(),ex);
		}
		return false;
		
	}	
	
	/**
	 * Hacky way to let subclasses change the type of the property data file so the correct reader is instantiated.
	 * 
	 * @param msPDF, a MS property data file that might need to be re-instantiated
	 * @return the passed MSPropertyDataFile if the proper type or the newly instantiated one by a subclass
	 */
	public MSPropertyDataFile getUpdatePropertyDataFile( MSPropertyDataFile msPDF ) {
		return msPDF;
	}
	
	/**
	 * Hacky way to let subclasses change the type of the property data files so the correct reader is instantiated.
	 * 
	 * @param metaData, the MassSpecMetaData that has data files
	 */
	public void updateMSPropertyDataFiles( MassSpecMetaData metaData ) {
		// nothing to do here!
	}

	@Override
	public Object clone() {
		MassSpecProperty newProp = new MassSpecProperty();	
		if ( getMassSpecMetaData() != null ) {
			MassSpecMetaData settings = (MassSpecMetaData) getMassSpecMetaData().clone();
			newProp.setDataFiles(getDataFiles());
			newProp.setMassSpecMetaData(settings);
		}
		return newProp;
	}

	@Override
	public Property getParentProperty() {
		// TODO Auto-generated method stub
		return null;
	}	
	
	@Override
	public void makeACopy(Entry currentEntry, Entry destinationEntry) throws NotImplementedException, IOException {
		String currentFileFolder = getFullyQualifiedFolderName(currentEntry);
		String workspaceLocation = PropertyHandler.getVariable("workspace_location");
		String newProjectName = destinationEntry.getParent().getParent().getDisplayName();
		String destinationFolder = workspaceLocation + newProjectName + File.separator + MassSpecProperty.getFoldername();
		
		MassSpecMetaData msSettings = getMassSpecMetaData();
		MassSpecMetaData newMsSettings = (MassSpecMetaData) msSettings.clone();
		newMsSettings.setVersion(MassSpecMetaData.CURRENT_VERSION);
		if (msSettings != null) {
			SimpleDateFormat formater = new SimpleDateFormat("yyyy.MM.dd-HH.mm.ss.SSSS");
			Date date = new Date();
			String newMsEntryPath = formater.format(date);

			File destMSPath = new File(destinationFolder + File.separator + newMsEntryPath);
			destMSPath.mkdirs();
			
			newMsSettings.setFileList(copyFiles (msSettings.getFileList(), 
					currentFileFolder, destinationFolder, newMsEntryPath));
			
			// update any externalQuantAlias source file names
			HashMap<String, ExternalQuantFileToAlias> map = msSettings.getQuantTypeToExternalQuant();
			if (map != null) {
				HashMap<String, ExternalQuantFileToAlias> newMap = new HashMap<String, ExternalQuantFileToAlias>();
				for (Map.Entry<String, ExternalQuantFileToAlias> entry: map.entrySet()) {
					ExternalQuantFileToAlias alias = entry.getValue();
					ExternalQuantFileToAlias newAlias = new ExternalQuantFileToAlias();
					HashMap<String, ExternalQuantAlias> fileMap = alias.getSourceDataFileNameToAlias();
					HashMap<String, ExternalQuantAlias> newFileMap = new HashMap<String, ExternalQuantAlias>();
					for (Map.Entry<String, ExternalQuantAlias> fileEntry: fileMap.entrySet()) {
						String fileName = fileEntry.getKey();
						String simpleFileName = new File (fileName).getName();
						String newFileName = newMsEntryPath + File.separator + simpleFileName;
						newFileMap.put(newFileName, fileEntry.getValue());
					}
					newAlias.setSourceDataFileNameToAlias(newFileMap);
					newMap.put(entry.getKey(), newAlias);
				}
				newMsSettings.setQuantTypeToExternalQuant(newMap);
			}
			
			//after the modifications, save the settings file to the new location
			String msDetails = "msMetaData.xml";
			marshallSettingsFile(destMSPath + File.separator + msDetails, newMsSettings);
			
			MassSpecProperty newProperty = getNewMSProperty();
			List<PropertyDataFile> newDataFiles = new ArrayList<PropertyDataFile>();
			
			for (PropertyDataFile file: dataFiles) {
				PropertyDataFile newFile = new PropertyDataFile();
				newFile.setType(file.getType());
				newFile.setVersion(file.getVersion());
				String simpleFileName = new File (file.getName()).getName();
				newFile.setName(newMsEntryPath + File.separator + simpleFileName);
				newDataFiles.add(newFile);
			}
			
			newProperty.setDataFiles(newDataFiles);
			newProperty.setMassSpecMetaData(newMsSettings);
			destinationEntry.setProperty(newProperty);
			
			copyLockFile(currentEntry, destinationFolder, newMsEntryPath);
		}
	}
	
	List<MSPropertyDataFile> copyFiles (List<MSPropertyDataFile> fileList, String currentFileFolder, String destinationFolder, String msEntryPath) throws IOException {
		
		if (fileList == null)
			return null;
		
		List<MSPropertyDataFile> newFileList = new ArrayList<MSPropertyDataFile>();
		for (MSPropertyDataFile file: fileList) {
			// these are all the mzxml, raw, xml files
			// change names and copy
			MSPropertyDataFile cloneFile = (MSPropertyDataFile) file.clone();
			if (!file.getName().trim().isEmpty()) {
				File currentFile = new File (currentFileFolder, file.getName());
				String simpleFileName = currentFile.getName();
				cloneFile.setName(msEntryPath + File.separator + simpleFileName);
				File destinationFile = new File(destinationFolder, cloneFile.getName());
				Files.copy(currentFile.toPath(), destinationFile.toPath());
			}
			
			newFileList.add(cloneFile);
			cloneFile.setChildren(copyFiles (file.getChildren(), currentFileFolder, destinationFolder, msEntryPath));
		}
		return newFileList;
	}
	
	/**
	 * copies the lock from to a new ms entry by changing the filename references
	 * 
	 * @param originalPath original folder for the specific ms entry (xxxx/ms/2016.xxxxx)
	 * @param destinationFolder the folder to copy the lock file, ms folder only (xxxx/ms)
	 * @param msEntryPath specific folder of the ms entry (2016.12.23.xxxx)
	 * @throws JAXBException 
	 * @throws IOException 
	 */
	void copyLockFile (Entry currentEntry, String destinationFolder, String msEntryPath) throws IOException {
		String original = getLockFilePath(currentEntry);
		try {
			FileLockManager mng = FileLockingUtils.readLockFile(original);
			String path = destinationFolder + File.separator + msEntryPath + File.separator + FileLockManager.LOCKFILE_NAME;
			if (mng != null && mng.getFileList() != null) {
				for (FileLock lock: mng.getFileList()) {
					String simpleFileName = new File (lock.getFilename()).getName();
					lock.setFilename(msEntryPath + File.separator + simpleFileName);
				}
			}
			FileLockingUtils.writeLockFile(mng, path);
		} catch (JAXBException e) {
			logger.warn("Cannot read/write the lock file for copying", e);
		}
	}
	
	/**
	 * subclasses should overwrite to return the proper type
	 * @return a new MassSpecProperty 
	 */
	public MassSpecProperty getNewMSProperty () {
		MassSpecProperty t_property = new MassSpecProperty();
		t_property.setVersion(CURRENT_VERSION);
		return t_property;
	}
}
